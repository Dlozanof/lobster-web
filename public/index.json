
[{"content":" Renode # I plan to use real hardware, but wanted to have Renode running to easily check changes without handling boards. It was rather easy to setup. The only notable point is that I created a script to automatically load the code.\n:name: Mi-V :description: Debugging script. $name?=\u0026#34;Mi-V\u0026#34; mach create $name machine LoadPlatformDescription @platforms/boards/stm32f4_discovery.repl $bin?=@/whatever/lobster/target/thumbv7em-none-eabihf/debug/lobster macro reset \u0026#34;\u0026#34;\u0026#34; sysbus LoadELF $bin \u0026#34;\u0026#34;\u0026#34; runMacro $reset machine StartGdbServer 3333 Which I can run with\nrenode --hide-monitor renode_start.resc And then connect to it via GDB\narm-none-eabi-gdb target/thumbv7em-none-eabihf/debug/lobster Minimal setup # Let us try to have a hello world example going on\u0026hellip;. My plan is to leverage stm32-rs project. Specifically it seems there is a readily available BSP I could use.\nRTIC seems to use this approach, and I might be able to do the same. Let\u0026rsquo;s see.\nFor now let\u0026rsquo;s try to follow the memfault guide for bare metal rust booting (1). Or not. Right out of the bat I see there are several undocumented parts so I will switch to another source. Let\u0026rsquo;s see if any of the official works of the Embedded workgroup is ok.\nhttps://docs.rust-embedded.org/book/ https://docs.rust-embedded.org/ https://docs.rust-embedded.org/embedonomicon/ For now I see I need several things. First one of them is a recent version of rustc. I find the rustc book interesting to know what the fuck should I do. Like updating. But using rustup. In this case I did check and update.\nI also seem to need cargo-binutils and cargo-embed . They look nice so I do install them.\nReferences:\n(1) https://interrupt.memfault.com/blog/zero-to-main-rust-1 https://github.com/rust-embedded/awesome-embedded-rust#hal-implementation-crates ","date":"14 March 2024","externalUrl":null,"permalink":"/posts/introduction/","section":"Posts","summary":"Renode # I plan to use real hardware, but wanted to have Renode running to easily check changes without handling boards.","title":"git commit -m \"Initial commit\"","type":"posts"},{"content":"","date":"14 March 2024","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":" Welcome! During Lobster development I\u0026#39;ll be using this website to post blog entries as a way of documenting the history of the project. I was taking notes locally, so might as well publish them. Cool! But, what is Lobster?. Glad you asked! I can tell you this: it is NOT an operating system nor an RTOS. It provides a small execution framework that I am making as a way to learning a bit of the internal of commonly used RTOS. It is written in Rust and focuses in providing a simple way to writting applications that handle data flows. I see. I do not feel you answered the question though. Well... With it you can define a data structure that will be provided by a certain peripheral, and then just wait for it to come. From application point of view no peripheral handling has to be done, you just receive the structs you expect (using Rust futures) and process them as you need. ","date":"14 March 2024","externalUrl":null,"permalink":"/","section":"Welcome to Lobster!","summary":"Welcome!","title":"Welcome to Lobster!","type":"page"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]